# 75. 分类颜色

[链接](https://leetcode-cn.com/problems/sort-colors/description/)

给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**
 不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

- 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

**思路分析：**

**1趟扫描**

使用3个指针：`l`，`m`，`r`。`l`左边的元素都为`0`，将其初始化为`0`，`r`右边的元素都为`2`，将其初始化为`nums.size() - 1`

首先往右移动`l`、往左移动`r`，使这2个指针到达正确的位置。然后初始化`m`为`l`，使用`m`从左往右遍历中间的元素，因此`nums[m]`可能有3个值：

- 如果`nums[m] == 1`，那么不需要交换，直接右移`m`
- 如果`nums[m] == 0`，因为`l`位置的值为`1`，因此交换`m`和`l`位置的值，然后右移`l`和`m`
- 如果`nums[m] == 2`，`m`位置的值可能为`0`也可能为`1`，因此交换`m`和`r`位置的值，然后左移`r`。但是需不需要右移`m`？**不需要**。因为如果交换后`m`位置的值为1，那么下次遍历会递增`m`；如果交换后`m`位置的值为0，那么还要与`l`位置的值进行交换。因此`m`保持不动

**具体实现：**

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while(l <= r && nums[l] == 0) l++;
        while(l <= r && nums[r] == 2) r--;
        int m = l;
        while(m <= r){
            if(nums[m] == 0) swap(nums[m++], nums[l++]);
            else if(nums[m] == 1) m++;
            //注意：m此时不自增1
            else if(nums[m] == 2) swap(nums[m], nums[r--]);
        }
    }
};
```

