# Leetcode60. 第K个排列

[OJ链接](https://leetcode.com/problems/permutation-sequence/description/)

给出集合 `[1,2,3,…,n]`，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 n 和 k，返回第 k 个排列。

说明：

- 给定 n 的范围是 [1, 9]。
- 给定 k 的范围是 [1, n!]。

示例 1:

```
输入: n = 3, k = 3
输出: "213"
```

示例 2:

```
输入: n = 4, k = 9
输出: "2314"
```

**思路分析：**

- 方法一：

  - 基于下一排列的方法，参考leetcode31
  - 时间复杂度O（n * k）
  - 空间复杂度O（1）

- 方法二：

  [参考链接](https://www.bilibili.com/video/av59677454?from=search&seid=8282304374183644688)

  - 当n为4时，可以按最高位划分成4组数：

```
1 + (2,3,4)
2 + (1,3,4)
3 + (1,2,4)
4 + (1,2,3)
```

- ​	因此，如果知道每组数有多少个，那么就可以判断第k个排列在哪一组，从而可以设置结果的最高位数字。进一步，对于剩下的3个数字，也可以固定最高位，然后进一步判断要求的排列在哪一组，从而可以设置结果的次高位数字...，一直处理直到结果的所有位都被设置。为了判断每组数有多少个，要先求出`1!,2!,...,(n - 1)!`
  - 时间复杂度：O(n * n)，erase操作会有n的复杂度（每次设置结果字符串中的一个数字，就需要O(n)的时间从list中删除这个数字，不过当k为0后，设置的每个数字都是list的开头数字，所以只需O(1)的时间就能删除）
  - 空间复杂度：O(1)

```C++
class Solution {
public:
    string getPermutation(int n, int k) {
        string res;
        string nums = "123456789";
        vector<int> fac(n, 1);
        for(int i = 1; i < n; i++){
            fac[i] = fac[i - 1] * i;
        }
        //相当于排列组合从0开始排号
        --k;
        for(int i = n; i > 0; i--){
            int j = k / fac[i - 1];
            k = k % fac[i - 1];
            res.push_back(nums[j]);
            nums.erase(j, 1);
        }
        return res;

    }
};
```

